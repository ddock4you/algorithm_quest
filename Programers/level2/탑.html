<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>탑</title>
    </head>
    <body>
        <script>
            // 큐, 스택 방식이 아니라서 테스트 통과가 안되고 있음.
            // const solution = (heights) => {
            //     const arr = new Array(heights.length).fill(0);
            //     for (let i = heights.length - 1; i > 0; i -= 1) {
            //         for (let j = i - 1; j > 0; j -= 1) {
            //             if (heights[i] < heights[j]) {
            //                 arr[i] = j + 1;
            //                 break;
            //             }
            //             console.log(
            //                 `heights[${i}]: ${heights[i]}, heights[${j}]: ${heights[j]}`
            //             );
            //         }
            //     }
            //     return arr;
            // };

            const solution = (heights) => {
                return heights.map((top, index) => {
                    const list = heights.slice(0, index + 1).reverse();
                    const find = list.findIndex((f) => f > top);
                    console.log(list, find);
                    return find > 0 ? list.length - find : 0;
                });
            };

            // Array.prototype.map()을 이용하여 heights 배열을 새로 생성
            // list = 현재 index까지 탑의 높이를 역순으로 복사하여 저장.
            // 역순->신호의 방향이 index가 높은 곳에서 낮은 곳(좌측)으로 가기 때문.
            // 현재 index까지인 이유 -> 현재 인덱스에서 우측으로 신호가 가지 않음.
            // 즉, 어떠한 경우에도 첫번째 탑은 수신할 수 있는 탑이 없음.
            // find = Array.prototype.findIndex() = list 배열을 돌면서 자신보다 높은 탑의 첫번째 index를 반환함.
            // 역순으로 배열을 저장했기 때문에 (list.length-find)로 정순일 때의 위치 반환. 수신할 탑이 없으면 0

            console.log(solution([5, 3, 1, 2, 3]));
        </script>
    </body>
</html>
